# 1035. Password (20)
[原题地址](https://www.patest.cn/contests/pat-a-practise/1035)

* 时间限制 400 ms

* 内存限制 65536 kB

* 代码长度限制 16000 B

* 判题程序 Standard 

* 题目作者 CHEN, Yue



To prepare for PAT, the judge sometimes has to generate random passwords for the users. The 
problem is that there are always some confusing passwords since it is hard to distinguish 1 
(one) from l (L in lowercase), or 0 (zero) from O (o in uppercase). One solution is to replace 
1 (one) by @, 0 (zero) by %, l by L, and O by o. Now it is your job to write a program to check 
the accounts generated by the judge, and to help the juge modify the confusing passwords.

## Input Specification: 

Each input file contains one test case. Each case contains a positive integer N (<= 1000), 
followed by N lines of accounts. Each account consists of a user name and a password, both 
are strings of no more than 10 characters with no space.



## Output Specification: 

For each test case, first print the number M of accounts that have been modified, then print in 
the following M lines the modified accounts info, that is, the user names and the corresponding 
modified passwords. The accounts must be printed in the same order as they are read in. If no 
account is modified, print in one line "There are N accounts and no account is modified" where N 
is the total number of accounts. However, if N is one, you must print "There is 1 account and no 
account is modified" instead.


## Sample Input 1:

3  
Team000002 Rlsp0dfa  
Team000003 perfectpwd  
Team000001 R1spOdfa  

## Sample Output 1:

2  
Team000002 RLsp%dfa  
Team000001 R@spodfa  


## Sample Input 2:

1  
team110 abcdefg332  

## Sample Output 2:

There is 1 account and no account is modified


## Sample Input 3:

2  
team110 abcdefg222  
team220 abcdefg333  

## Sample Output 3:

There are 2 accounts and no account is modified  



## 题意：

对用户的密码中的一些字符进行如下替换：{'1' -> '@'}, {'0' -> '%'}, {'l' -> 'L'}, {'O' -> 'o'}，
输入N个用户的名字与密码，进行替换后输出替换的数量及每个替换过的用户的名字和密码(按输入顺序排序)，
若没有密码需要替换，则根据N的值输出"There are" + N +＂accounts and no account is modified"，(N > 1)
或"There is 1 account and no account is modified"(N为1)

## 思路：

用map<char, char> hash存储字符替换对应，赋值为{ {'1','@'}, {'0', '%'}, {'l', 'L'}, {'O', 'o'} }，
vector<string> users存储需要替换的用户名，map<string, string> nameToPassword存储需要替换的用户的
名字与密码的对应，

对于N个输入，每个遍历密码的每个字符，若有字符存在于hash的key值中，将此字符替换为其hash对应的字符，
并将替换过的用户存储在users中，并将其名字与密码的对应存储在nameToPassword中

最后输出users中的所有名字与其在nameToPassword中的对应密码

## 代码：

[1035. Password (20).cpp](https://github.com/jerrykcode/PAT-Practise/blob/master/PAT%20Advanced%20Level%20Practise/1035.%20Password%20(20)/1035.%20Password%20(20).cpp)


```cpp
#include "stdafx.h"
#include <iostream>
using namespace std;
#include <map>
#include <vector>
#include <string>

int main()
{
	map<string, string> nameToPassword;
	vector<string>users;
	map<char, char>hash = { {'1','@'}, {'0', '%'}, {'l', 'L'}, {'O', 'o'} };
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		string name, pw;
		cin >> name >> pw;
		int flag = 0;
		for (int j = 0; j < pw.length(); j ++)
			if (hash.find(pw[j]) != hash.end()) {
				pw[j] = hash[pw[j]];
				flag = 1;
			}
		if (flag) {
			users.push_back(name);
			nameToPassword[name] = pw;
		}
	}
	if (users.size()) {
		cout << users.size() << endl;
		for (int i = 0; i < users.size(); i++)
			cout << users[i] << " " << nameToPassword[users[i]] << endl;
	}
	else
		cout << "There " << (n > 1 ? "are " : "is ") << n << (n > 1 ? " accounts" : " account") << " and no account is modified";
    return 0;
}
```

